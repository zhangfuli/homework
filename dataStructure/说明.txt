作业一:
实习目的：熟练掌握链表的建立及基本操作

问题描述：

1）实现链表的排序(升序)

2）实现两个有序链表的合并：A=A∪B，要求合并后仍然有序。

提交前请将所有的提示信息去掉，只保留最后的输出结果。例如运行时：从键盘直接输入：

2 1 2
3 1 2 3 

输出结果为：

1
2
3

分别表示第一个链表元素个数为2，元素分别为 1,2 ；第二个链表元素个数为3，元素分别为1,2,3。

作业二:
一元多项式的基本运算

实验目的：掌握用线性表实现一元多项式的基本运算。

实验内容：使用链式存储实现一元多项式的加法、减法、乘法和求导。即：

C(x)= A(x)+B(x)；C(x)= A(x)-B(x) C(x)= A(x)*B(x) C(x)= A’(x)

菜单：

1)C ：分别创建两个多项式A(x)和B(x)，其中 输入时按照 指数的升序顺序输入，遇到系数为0则停止。例如：输入 ：

1 2 3 4 5 6 7 8

0 2 3 4 5 6 7 0 则生成的多项式分别为：

A(x)=x^2+3x^4+5x^6+7x^8

B(x)=2x^3+4x^5+6x^7

2)P:计算C(x)= A(x)+B(x)，计算完毕后输出C(x)的 结果

3)S: 计算C(x)= A(x)-B(x)，计算完毕后输出C(x)的 结果

4)M: 计算C(x)= A(x)*B(x)，计算完毕后输出C(x)的 结果

5)D: 计算C(x)= A’(x)，计算完毕后输出C(x)的 结果

6)V: 首先输入一个 float型数据，然后计算 A(x)并输出计算的结果。

7)C: 分别清空A(x)、B(x)、C(x)三个多项式。

8)X: 退出程序。

括号匹配：
用栈实现：输入一行符号,以#结束，判断其中的括号是否匹配。括号包括：[],<>,{},()

第一次课堂之星：


已知三个带头结点的线性链表A、B和C中的结点均依元素值自小至大非递减排列（可能存在两个以上值相同的结点），编写算法对A表进行如下操作：使操作后的链表A中仅留下三个表中均包含的数据元素的结点，且没有值相同的结点，并释放所有无用结点。限定算法的时间复杂度为O（m+n+p），其中m、n和p分别为三个表的长度。


稀疏矩阵的压缩存储：

实现稀疏矩阵压缩存储，并实现矩阵转置和求和。

输入矩阵时，首先需要输入非零元素的个数，然后分别输入矩阵的 行号，列号和值。

输完2个矩阵后，自动进行计算第一个矩阵的转置以及两个矩阵的和。



bintreenode

实现二叉树的基本操作：建立、遍历、计算深度、结点数、叶子数等。

输入C，先序创建二叉树，#表示空节点；

输入H：计算二叉树的高度；

输入L：计算二叉树的叶子个数；

输入N：计算二叉树节点总个数；

输入1：先序遍历二叉树；

输入2：中序遍历二叉树；

输入3：后续遍历二叉树；

输入F：查找值=x的节点的个数；

输入P：以缩格文本形式输出所有节点。

二叉树与表达式

将通过二叉链表实现的表达式二叉树进行输出，同时计算出结果。

要求：

1）二叉树建立时，使用先序建立；

2）四个运算符包括：+, -, *, /;

3 ) 在输出时，遇到优先级问题时，相应的括号也要输出。

提示：

1）递归执行下列步骤即可求值：先分别求出左子树和右子树表示的子表达式的值，最后根据根结点的运算符的要求，计算出表达式的最后结果。

2）二叉树的中序遍历序列与原算术表达式基本相同，但是需要将中序序列加上括号，即当根结点运算符优先级高于左子树（或右子树）根结点运算符时，就需要加括号。


实现图的基本操作：

建立图(邻接矩阵、邻近表任选其一)的存储结构、实现图的深度优先遍历和广度优先遍历。


排序算法的应用：

设有顺序放置的n个桶，每个桶中装有一粒砾石，每粒砾石的颜色是红,白,蓝之一。要求重新安排这些砾石，使得所有红色砾石在前，所有白色砾石居中，所有蓝色砾石居后，重新安排时对每粒砾石的颜色只能看一次，并且只允许交换操作来调整砾石的位置。

解释：

利用快速排序思想解决。由于要求“对每粒砾石的颜色只能看一次”，设3个指针i，j和k，若将j看作工作指针，将r[1..j-1]作为红色，r[j..k-1]为白色，r[k..n]为兰色。从j=1开始查看，若r[j]为白色，则j=j+1；若r[j]为红色，则交换r[j]与r[i]，且j=j+1，i=i+1；若r[j]为兰色，则交换r[j]与r[k];k=k-1。算法进行到j>k为止。

为方便处理，将三种砾石的颜色用整数1、2和3表示。

HASH：
hash查找链表